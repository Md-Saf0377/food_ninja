<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Food Ninja</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #2c3e50; /* Dark background outside canvas */
            font-family: "Inter", sans-serif;
            -webkit-user-select: none; /* Disable text selection on iOS */
            -moz-user-select: none; /* Disable text selection on Firefox */
            -ms-user-select: none; /* Disable text selection on IE/Edge */
            user-select: none; /* Standard property to disable text selection */
            touch-action: none; /* Prevent default touch actions like scrolling */
        }
        canvas {
            display: block;
            background-color: #eee; /* Fallback if background image doesn't load */
            border-radius: 12px; /* Rounded corners for the canvas */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3); /* Subtle shadow */
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        // Get the canvas element and its 2D rendering context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Base game dimensions for scaling (from original Python code)
        const BASE_GAME_WIDTH = 800;
        const BASE_GAME_HEIGHT = 600;

        // Current canvas dimensions, updated on resize
        let currentWidth = window.innerWidth;
        let currentHeight = window.innerHeight;

        // Game state variables
        let lifelines = 3;
        let score = 0;
        let foods = [];
        let slicing = false;
        let slicePositions = []; // Stores points of the slice path
        let gameOver = false;

        // Background scrolling variables
        let bgImageRaw; // Original background image
        let bgImage;    // Scaled background image (canvas element)
        let bgX1 = 0;
        let bgX2;
        const bgScrollSpeed = 1; // Base scroll speed

        // Image assets (placeholders for now)
        let burgerImg, pizzaImg, vegImg, carrotImg;

        // Colors
        const WHITE = 'rgb(255, 255, 255)';
        const BLACK = 'rgb(0, 0, 0)';
        const RED = 'rgb(255, 0, 0)';

        // --- Helper Functions ---

        /**
         * Scales a value proportionally based on the current canvas dimensions
         * relative to the base game dimensions.
         * @param {number} value - The value to scale.
         * @param {'width'|'height'} dimension - The dimension to scale against ('width' or 'height').
         * @returns {number} The scaled value.
         */
        function scaleValue(value, dimension) {
            if (dimension === 'width') {
                return value * (currentWidth / BASE_GAME_WIDTH);
            } else if (dimension === 'height') {
                return value * (currentHeight / BASE_GAME_HEIGHT);
            }
            return value;
        }

        /**
         * Loads an image and returns a Promise that resolves with the Image object.
         * @param {string} src - The URL of the image.
         * @returns {Promise<HTMLImageElement>} A promise that resolves with the loaded image.
         */
        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = () => reject(new Error(`Failed to load image: ${src}`));
                img.src = src;
            });
        }

        /**
         * Creates a circular version of an image on a new canvas.
         * @param {HTMLImageElement} image - The source image.
         * @param {number} size - The desired size of the circular image (diameter).
         * @returns {HTMLCanvasElement} A new canvas containing the circular image.
         */
        function makeCircleImage(image, size) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = size;
            tempCanvas.height = size;
            const tempCtx = tempCanvas.getContext('2d');

            // Draw the image onto the temporary canvas
            tempCtx.drawImage(image, 0, 0, size, size);

            // Use globalCompositeOperation to create a circular mask
            tempCtx.globalCompositeOperation = 'destination-in';
            tempCtx.beginPath();
            tempCtx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
            tempCtx.fill();
            tempCtx.globalCompositeOperation = 'source-over'; // Reset to default

            return tempCanvas;
        }

        /**
         * Loads all game images and processes them (e.g., making them circular).
         */
        async function loadAllImages() {
            try {
                // Using placeholder images from placehold.co
                const [rawBurger, rawPizza, rawVeg, rawCarrot, rawBg] = await Promise.all([
                    loadImage("images/g1.jpg"),
                    loadImage("images/g2.jpg"),
                    loadImage("images/g3.jpg"),
                    loadImage("images/g4.jpg"),
                    loadImage("images/background.jpg")
                ]);

                const foodBaseSize = 80; // Base size for circular food images

                burgerImg = makeCircleImage(rawBurger, foodBaseSize);
                pizzaImg = makeCircleImage(rawPizza, foodBaseSize);
                vegImg = makeCircleImage(rawVeg, foodBaseSize);
                carrotImg = makeCircleImage(rawCarrot, foodBaseSize);

                bgImageRaw = rawBg;
                resizeCanvas(); // Call resize after loading to set initial background dimensions
                console.log("All images loaded successfully.");
            } catch (error) {
                console.error("Error loading images:", error);
                // Optionally display an error message on canvas
                ctx.fillStyle = BLACK;
                ctx.font = '24px Arial';
                ctx.fillText("Error loading images. Please refresh.", 50, 50);
            }
        }

        /**
         * Resizes the canvas to fill the window and recalculates background dimensions.
         */
        function resizeCanvas() {
            currentWidth = window.innerWidth;
            currentHeight = window.innerHeight;
            canvas.width = currentWidth;
            canvas.height = currentHeight;

            // Recalculate background image scaling
            if (bgImageRaw) {
                // Scale background to fit height, then ensure it covers full width
                bgScaleFactor = currentHeight / bgImageRaw.height;
                const tempBgWidth = Math.floor(bgImageRaw.width * bgScaleFactor);
                
                // Create a temporary canvas to draw the scaled background image
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = Math.max(currentWidth, tempBgWidth);
                tempCanvas.height = currentHeight;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(bgImageRaw, 0, 0, tempCanvas.width, tempCanvas.height);
                bgImage = tempCanvas; // Store the scaled background canvas
                
                // Update bgX2 based on the new scaled background width
                bgX2 = bgX1 + bgImage.width;
            }
        }

        // --- Game Classes ---

        /**
         * Represents a single food item falling down the screen.
         */
        class Food {
            static BASE_SPEED = 2;
            static SPEED_INCREMENT = 0.1;
            static MAX_SPEED = 10;

            /**
             * @param {number} x - Initial x-coordinate.
             * @param {number} y - Initial y-coordinate.
             * @param {string} kind - Type of food ('burger', 'pizza', 'veg', 'carrot').
             * @param {HTMLCanvasElement} image - The circular image canvas for this food type.
             */
            constructor(x, y, kind, image) {
                this.x = x;
                this.y = y;
                this.kind = kind;
                this.sliced = false;
                this.image = image; // This is now a canvas element

                // Store original image dimensions for proportional scaling
                this.originalWidth = image.width;
                this.originalHeight = image.height;
            }

            /**
             * Moves the food item downwards, increasing speed with score.
             * @param {number} currentScore - The current game score.
             */
            move(currentScore) {
                const speed = Math.min(Food.BASE_SPEED + Food.SPEED_INCREMENT * currentScore, Food.MAX_SPEED);
                this.y += scaleValue(speed, 'height'); // Scale speed based on height
            }

            /**
             * Draws the food item on the canvas, with scaling and alpha based on its y-position.
             * @param {CanvasRenderingContext2D} ctx - The canvas rendering context.
             */
            draw(ctx) {
                const minScale = 0.5;
                const maxScale = 1.2;
                // Scale based on food's Y position relative to canvas height
                const scaleFactor = minScale + (maxScale - minScale) * (this.y / currentHeight);

                // Calculate scaled dimensions, ensuring minimum size
                const scaledWidth = Math.max(1, Math.floor(scaleValue(this.originalWidth, 'width') * scaleFactor));
                const scaledHeight = Math.max(1, Math.floor(scaleValue(this.originalHeight, 'height') * scaleFactor));

                // Calculate alpha for fading in/out
                const minAlpha = 100;
                const maxAlpha = 255;
                const alpha = minAlpha + Math.floor((maxAlpha - minAlpha) * (this.y / currentHeight));

                ctx.save(); // Save current context state
                ctx.globalAlpha = alpha / 255; // Set global alpha

                // Draw the scaled image at its scaled position
                ctx.drawImage(
                    this.image,
                    scaleValue(this.x, 'width') - scaledWidth / 2,
                    scaleValue(this.y, 'height') - scaledHeight / 2,
                    scaledWidth,
                    scaledHeight
                );

                ctx.restore(); // Restore context state
            }

            /**
             * Gets the current bounding rectangle of the food item on the canvas.
             * This is used for collision detection.
             * @returns {object} An object with x, y, width, and height properties.
             */
            getRect() {
                const minScale = 0.5;
                const maxScale = 1.2;
                const scaleFactor = minScale + (maxScale - minScale) * (this.y / currentHeight);

                const scaledWidth = Math.max(1, Math.floor(scaleValue(this.originalWidth, 'width') * scaleFactor));
                const scaledHeight = Math.max(1, Math.floor(scaleValue(this.originalHeight, 'height') * scaleFactor));

                return {
                    x: scaleValue(this.x, 'width') - scaledWidth / 2,
                    y: scaleValue(this.y, 'height') - scaledHeight / 2,
                    width: scaledWidth,
                    height: scaledHeight
                };
            }
        }

        /**
         * Represents a clickable button in the game.
         */
        class Button {
            /**
             * @param {string} text - The text displayed on the button.
             * @param {number} x - Base x-coordinate of the button.
             * @param {number} y - Base y-coordinate of the button.
             * @param {number} width - Base width of the button.
             * @param {number} height - Base height of the button.
             * @param {number} elevation - Base elevation for the 3D effect.
             */
            constructor(text, x, y, width, height, elevation = 6) {
                this.text = text;
                this.baseX = x;
                this.baseY = y;
                this.baseWidth = width;
                this.baseHeight = height;
                this.elevation = elevation;
                this.dynamicElevation = elevation;
                this.pressed = false;

                this.topColor = 'rgb(70, 95, 119)';
                this.bottomColor = 'rgb(53, 75, 94)';
                this.hoverColor = 'rgb(100, 130, 160)';
                this.pressedColor = 'rgb(40, 60, 80)';
            }

            /**
             * Draws the button on the canvas.
             * @param {CanvasRenderingContext2D} ctx - The canvas rendering context.
             * @returns {boolean} True if the button was clicked on this frame, false otherwise.
             */
            draw(ctx) {
                const mouseX = lastMouseX; // Use last known mouse/touch position
                const mouseY = lastMouseY;

                // Scale button dimensions and position
                const scaledX = scaleValue(this.baseX, 'width');
                const scaledY = scaleValue(this.baseY, 'height');
                const scaledWidth = scaleValue(this.baseWidth, 'width');
                const scaledHeight = scaleValue(this.baseHeight, 'height');
                const scaledElevation = scaleValue(this.elevation, 'height');
                const scaledDynamicElevation = scaleValue(this.dynamicElevation, 'height');

                const topRect = {
                    x: scaledX,
                    y: scaledY + scaledDynamicElevation - scaledElevation,
                    width: scaledWidth,
                    height: scaledHeight
                };
                const bottomRect = {
                    x: scaledX,
                    y: scaledY + scaledDynamicElevation,
                    width: scaledWidth,
                    height: scaledHeight + scaledElevation
                };

                let clicked = false;
                const isHovered = mouseX >= topRect.x && mouseX <= topRect.x + topRect.width &&
                                  mouseY >= topRect.y && mouseY <= topRect.y + topRect.height;

                if (isHovered && isMouseDown) {
                    this.topColor = this.pressedColor;
                    this.dynamicElevation = 0;
                    this.pressed = true;
                } else {
                    this.dynamicElevation = this.elevation;
                    if (isHovered) {
                        this.topColor = this.hoverColor;
                        if (this.pressed && !isMouseDown) { // Button was pressed and now released
                            clicked = true;
                            this.pressed = false;
                        }
                    } else {
                        this.topColor = 'rgb(70, 95, 119)';
                        this.pressed = false;
                    }
                }

                // Draw bottom layer (shadow/depth)
                ctx.fillStyle = this.bottomColor;
                ctx.beginPath();
                ctx.roundRect(bottomRect.x, bottomRect.y, bottomRect.width, bottomRect.height, scaleValue(12, 'width'));
                ctx.fill();

                // Draw top layer
                ctx.fillStyle = this.topColor;
                ctx.beginPath();
                ctx.roundRect(topRect.x, topRect.y, topRect.width, topRect.height, scaleValue(12, 'width'));
                ctx.fill();

                // Draw text
                ctx.fillStyle = BLACK;
                ctx.font = `${scaleValue(28, 'height')}px Inter`; // Scale font size
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.text, topRect.x + topRect.width / 2, topRect.y + topRect.height / 2);

                return clicked;
            }
        }

        // --- Game Logic Functions ---

        /**
         * Generates a new food item at a random position at the top of the screen.
         * @returns {Food} A new Food object.
         */
        function generateFood() {
            const kinds = ['burger', 'pizza', 'veg', 'carrot'];
            const weights = [0.4, 0.4, 0.1, 0.1]; // Weights for random selection

            // Simple weighted random selection
            let kind;
            const rand = Math.random();
            if (rand < weights[0]) {
                kind = 'burger';
            } else if (rand < weights[0] + weights[1]) {
                kind = 'pizza';
            } else if (rand < weights[0] + weights[1] + weights[2]) {
                kind = 'veg';
            } else {
                kind = 'carrot';
            }

            const x = Math.random() * (BASE_GAME_WIDTH - 100) + 50; // Random x within bounds
            const y = -50; // Start off-screen at the top

            let image;
            switch (kind) {
                case 'burger': image = burgerImg; break;
                case 'pizza': image = pizzaImg; break;
                case 'carrot': image = carrotImg; break;
                default: image = vegImg; break;
            }
            return new Food(x, y, kind, image);
        }

        /**
         * Draws the lifeline indicators on the canvas.
         * @param {CanvasRenderingContext2D} ctx - The canvas rendering context.
         * @param {number} count - The number of lifelines remaining.
         */
        function drawLifelines(ctx, count) {
            ctx.fillStyle = RED;
            for (let i = 0; i < count; i++) {
                ctx.beginPath();
                ctx.roundRect(
                    scaleValue(20 + i * 40, 'width'),
                    scaleValue(20, 'height'),
                    scaleValue(30, 'width'),
                    scaleValue(30, 'height'),
                    scaleValue(5, 'width') // Rounded corners for lifelines
                );
                ctx.fill();
            }
        }

        /**
         * Draws the current score on the canvas.
         * @param {CanvasRenderingContext2D} ctx - The canvas rendering context.
         * @param {number} score - The current game score.
         */
        function drawScore(ctx, score) {
            ctx.fillStyle = BLACK;
            ctx.font = `${scaleValue(36, 'height')}px Inter`; // Scale font size
            ctx.textAlign = 'right';
            ctx.textBaseline = 'top';
            ctx.fillText(`Score: ${score}`, currentWidth - scaleValue(20, 'width'), scaleValue(20, 'height'));
        }

        // --- Game Loop and Event Handling ---

        let lastFrameTime = 0;
        let foodSpawnInterval;
        let restartButton, quitButton;

        // Mouse/Touch state for button interactions
        let isMouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        /**
         * The main game loop, called repeatedly using requestAnimationFrame.
         * @param {DOMHighResTimeStamp} currentTime - The current time provided by requestAnimationFrame.
         */
        function animate(currentTime) {
            // Calculate delta time if needed for frame-rate independent movement (optional for this game)
            // const deltaTime = currentTime - lastFrameTime;
            // lastFrameTime = currentTime;

            // Clear the canvas
            ctx.clearRect(0, 0, currentWidth, currentHeight);

            // Update and draw background
            if (bgImage) {
                const scaledBgScrollSpeed = scaleValue(bgScrollSpeed, 'width');
                bgX1 -= scaledBgScrollSpeed;
                bgX2 -= scaledBgScrollSpeed;

                if (bgX1 <= -bgImage.width) {
                    bgX1 = bgX2 + bgImage.width;
                }
                if (bgX2 <= -bgImage.width) {
                    bgX2 = bgX1 + bgImage.width;
                }

                ctx.drawImage(bgImage, bgX1, 0, bgImage.width, bgImage.height);
                ctx.drawImage(bgImage, bgX2, 0, bgImage.width, bgImage.height);
            }

            if (!gameOver) {
                // Update and draw foods
                for (let i = foods.length - 1; i >= 0; i--) {
                    const food = foods[i];
                    food.move(score);
                    food.draw(ctx);

                    // Remove food if it goes off-screen
                    if (food.y > currentHeight + scaleValue(50, 'height')) {
                        // Removed the lifeline reduction for missed good food items here
                        foods.splice(i, 1);
                    }
                }

                // Handle slicing
                if (slicing && slicePositions.length > 1) {
                    // Draw the slice line
                    ctx.strokeStyle = RED;
                    ctx.lineWidth = scaleValue(3, 'width');
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(slicePositions[0].x, slicePositions[0].y);
                    for (let i = 1; i < slicePositions.length; i++) {
                        ctx.lineTo(slicePositions[i].x, slicePositions[i].y);
                    }
                    ctx.stroke();

                    // Check for food slicing
                    for (let i = foods.length - 1; i >= 0; i--) {
                        const food = foods[i];
                        if (food.sliced) continue;

                        const foodRect = food.getRect();
                        let hit = false;
                        for (const pos of slicePositions) {
                            // Simple point-in-rectangle collision
                            if (pos.x >= foodRect.x && pos.x <= foodRect.x + foodRect.width &&
                                pos.y >= foodRect.y && pos.y <= foodRect.y + foodRect.height) {
                                hit = true;
                                break;
                            }
                        }

                        if (hit) {
                            food.sliced = true;
                            foods.splice(i, 1); // Remove the sliced food
                            if (food.kind === 'veg' || food.kind === 'carrot') {
                                lifelines--; // Penalize for slicing bad food
                            } else {
                                score++; // Reward for slicing good food
                            }
                        }
                    }
                }

                drawLifelines(ctx, lifelines);
                drawScore(ctx, score);

                if (lifelines <= 0) {
                    gameOver = true;
                    clearInterval(foodSpawnInterval); // Stop spawning food
                }
            } else {
                // Game Over screen
                ctx.fillStyle = RED;
                ctx.font = `${scaleValue(60, 'height')}px Inter`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText("Game Over!", currentWidth / 2, currentHeight / 2 - scaleValue(60, 'height'));

                // Draw buttons
                if (restartButton.draw(ctx)) {
                    // Restart game
                    lifelines = 3;
                    score = 0;
                    foods.length = 0; // Clear foods array
                    slicing = false;
                    slicePositions.length = 0;
                    bgX1 = 0;
                    bgX2 = bgImage ? bgImage.width : currentWidth; // Reset bg position
                    gameOver = false;
                    foodSpawnInterval = setInterval(() => foods.push(generateFood()), 1000); // Restart spawning
                }
                if (quitButton.draw(ctx)) {
                    // Quit game (simply stop animation loop for web)
                    cancelAnimationFrame(animationFrameId);
                    // Optionally, show a "Thanks for playing" message or redirect
                    ctx.clearRect(0, 0, currentWidth, currentHeight);
                    ctx.fillStyle = BLACK;
                    ctx.font = `${scaleValue(40, 'height')}px Inter`;
                    ctx.fillText("Thanks for playing!", currentWidth / 2, currentHeight / 2);
                    return; // Stop further animation requests
                }
            }

            animationFrameId = requestAnimationFrame(animate);
        }

        let animationFrameId;

        /**
         * Initializes the game: loads images, sets up buttons, starts spawning, and begins the game loop.
         */
        async function initGame() {
            // Create buttons after canvas dimensions are potentially set
            restartButton = new Button("Restart", BASE_GAME_WIDTH / 2 - 110, BASE_GAME_HEIGHT / 2, 100, 50);
            quitButton = new Button("Quit", BASE_GAME_WIDTH / 2 + 10, BASE_GAME_HEIGHT / 2, 100, 50);

            await loadAllImages(); // Load images first

            // Start food spawning after images are loaded
            foodSpawnInterval = setInterval(() => {
                if (!gameOver) {
                    foods.push(generateFood());
                }
            }, 1000); // Every 1 second

            // Start the game loop
            animationFrameId = requestAnimationFrame(animate);
        }

        // --- Event Listeners ---

        window.addEventListener('resize', resizeCanvas);

        // Mouse events
        canvas.addEventListener('mousedown', (e) => {
            if (gameOver) {
                isMouseDown = true; // For button clicks on game over screen
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                return;
            }
            slicing = true;
            slicePositions = [{ x: e.clientX, y: e.clientY }];
            isMouseDown = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            if (slicing && !gameOver) {
                slicePositions.push({ x: e.clientX, y: e.clientY });
            }
        });

        canvas.addEventListener('mouseup', () => {
            slicing = false;
            slicePositions = [];
            isMouseDown = false;
        });

        // Touch events
        canvas.addEventListener('touchstart', (e) => {
            if (gameOver) {
                isMouseDown = true; // For button clicks on game over screen
                lastMouseX = e.touches[0].clientX;
                lastMouseY = e.touches[0].clientY;
                return;
            }
            slicing = true;
            const touch = e.touches[0];
            slicePositions = [{ x: touch.clientX, y: touch.clientY }];
            isMouseDown = true;
            lastMouseX = touch.clientX;
            lastMouseY = touch.clientY;
            e.preventDefault(); // Prevent scrolling/zooming
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            const touch = e.touches[0];
            lastMouseX = touch.clientX;
            lastMouseY = touch.clientY;
            if (slicing && !gameOver) {
                slicePositions.push({ x: touch.clientX, y: touch.clientY });
            }
            e.preventDefault(); // Prevent scrolling/zooming
        }, { passive: false });

        canvas.addEventListener('touchend', () => {
            slicing = false;
            slicePositions = [];
            isMouseDown = false;
        });

        // Initialize the game when the window loads
        window.onload = initGame;

    </script>
</body>
</html>
