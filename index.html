<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Food Ninja JS</title>
  <style>
    html, body { 
      margin: 0; 
      padding: 0; 
      overflow: hidden; 
      background: #222;
      touch-action: none;
      height: 100%;
      width: 100%;
    }
    body {
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }
    canvas { 
      display: block; 
      width: 100vw;
      height: 100vh;
      touch-action: none;
      background: #fff;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <script>
const WIDTH = 800, HEIGHT = 600;
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// Device pixel ratio handling
let dpr = window.devicePixelRatio || 1;
canvas.width = WIDTH * dpr;
canvas.height = HEIGHT * dpr;
ctx.setTransform(1,0,0,1,0,0); // Reset transform
ctx.scale(dpr, dpr);
canvas.style.width = WIDTH + 'px';
canvas.style.height = HEIGHT + 'px';

// Responsive resize
function resizeCanvas() {
  const targetWidth = window.innerWidth;
  const targetHeight = window.innerHeight;
  const scale = Math.min(targetWidth/WIDTH, targetHeight/HEIGHT);
  
  canvas.style.transform = `scale(${scale})`;
  canvas.style.transformOrigin = 'top left';
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// --- IMAGE SETUP ---
// You must provide your own images named as below in the same folder as this HTML file.
// If you want to use placeholder images, you can use data URLs or online images.
const images = {};
const imageFiles = {
  burger: 'g1.jpg',
  pizza: 'g2.jpg',
  veg: 'g3.jpg',
  carrot: 'g4.jpg',
  bg: 'background.jpg'
};
let loadedImages = 0;
const totalImages = Object.keys(imageFiles).length;

// Helper: replace with placeholder images if you don't have your own
function placeholderImage(color, text) {
  const cnv = document.createElement('canvas');
  cnv.width = 100; cnv.height = 100;
  const c = cnv.getContext('2d');
  c.fillStyle = color; c.fillRect(0,0,100,100);
  c.fillStyle = "#fff"; c.font = "20px Arial"; c.textAlign="center"; c.textBaseline="middle";
  c.fillText(text, 50, 50);
  return cnv.toDataURL();
}

// Try to load images, fallback to placeholder if not found
for (let key in imageFiles) {
  images[key] = new Image();
  images[key].src = imageFiles[key];
  images[key].onload = () => {
    loadedImages++;
    if (loadedImages === totalImages) startGame();
  };
  images[key].onerror = () => {
    // Fallback: simple colored placeholder
    let color = "#888";
    if(key==="burger") color="#a52a2a";
    if(key==="pizza") color="#e2c044";
    if(key==="veg") color="#228b22";
    if(key==="carrot") color="#ff7f50";
    if(key==="bg") color="#b0e0e6";
    images[key].src = placeholderImage(color, key);
    loadedImages++;
    if (loadedImages === totalImages) startGame();
  };
}

function startGame() {
  // Game variables
  let lifelines = 3, score = 0, foods = [], slicing = false, slicePositions = [];
  let gameOver = false;
  let lastSpawn = 0;
  let bgX1 = 0, bgX2 = WIDTH, bgScroll = 1;

  function Food(x, y, kind) {
    this.x = x;
    this.y = y;
    this.kind = kind;
    this.sliced = false;
    this.img = images[kind];
    this.size = 80;
    this.speed = 2;
  }
  Food.prototype.move = function() {
    this.y += this.speed + 0.1 * score;
  };
  Food.prototype.draw = function() {
    let scale = 0.5 + 0.7 * (this.y / HEIGHT);
    let w = this.size * scale, h = this.size * scale;
    ctx.globalAlpha = 0.4 + 0.6 * (this.y / HEIGHT);
    ctx.drawImage(this.img, this.x - w/2, this.y - h/2, w, h);
    ctx.globalAlpha = 1;
  };
  Food.prototype.contains = function(x, y) {
    let scale = 0.5 + 0.7 * (this.y / HEIGHT);
    let w = this.size * scale, h = this.size * scale;
    return (x > this.x - w/2 && x < this.x + w/2 && y > this.y - h/2 && y < this.y + h/2);
  };

  function spawnFood() {
    const kinds = ['burger','pizza','veg','carrot'];
    const weights = [0.4,0.4,0.1,0.1];
    let sum = weights.reduce((a,b)=>a+b,0);
    let r = Math.random() * sum, total = 0;
    let kind = kinds[0];
    for (let i=0; i<kinds.length; i++) {
      total += weights[i];
      if (r < total) { kind = kinds[i]; break; }
    }
    let x = 50 + Math.random() * (WIDTH - 100);
    foods.push(new Food(x, -50, kind));
  }

  function drawLifelines() {
    for (let i=0; i<lifelines; i++) {
      ctx.fillStyle = "red";
      ctx.fillRect(20 + i*40, 20, 30, 30);
    }
  }
  function drawScore() {
    ctx.font = "36px Arial";
    ctx.fillStyle = "#000";
    ctx.fillText("Score: " + score, WIDTH-170, 45);
  }

  function drawButtons() {
    // Restart Button
    ctx.fillStyle = "#466177";
    ctx.fillRect(WIDTH/2-110, HEIGHT/2, 100, 50, 12);
    ctx.fillStyle = "#000";
    ctx.font = "28px Arial";
    ctx.fillText("Restart", WIDTH/2-90, HEIGHT/2+33);

    // Quit Button
    ctx.fillStyle = "#466177";
    ctx.fillRect(WIDTH/2+10, HEIGHT/2, 100, 50, 12);
    ctx.fillStyle = "#000";
    ctx.fillText("Quit", WIDTH/2+45, HEIGHT/2+33);
  }

  function checkButtonClick(x, y) {
    const scale = parseFloat(canvas.style.transform.replace('scale(', '')) || 1;
    const rect = canvas.getBoundingClientRect();
    const logicalX = (x - rect.left) / scale;
    const logicalY = (y - rect.top) / scale;
    if (logicalY > HEIGHT/2 && logicalY < HEIGHT/2+50) {
      if (logicalX > WIDTH/2-110 && logicalX < WIDTH/2-10) return 'restart';
      if (logicalX > WIDTH/2+10 && logicalX < WIDTH/2+110) return 'quit';
    }
    return null;
  }

  // Input handling (mouse & touch)
  function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    const scale = parseFloat(canvas.style.transform.replace('scale(', '')) || 1;
    if (e.touches) {
      const t = e.touches[0] || e.changedTouches[0];
      return {
        x: (t.clientX - rect.left) / scale,
        y: (t.clientY - rect.top) / scale
      };
    } else {
      return {
        x: (e.clientX - rect.left) / scale,
        y: (e.clientY - rect.top) / scale
      };
    }
  }

  canvas.addEventListener('mousedown', e => { 
    if (!gameOver) { 
      slicing = true; 
      slicePositions = [getPos(e)]; 
    }
  });
  canvas.addEventListener('mouseup', e => { slicing = false; slicePositions = []; });
  canvas.addEventListener('mousemove', e => { if (slicing && !gameOver) slicePositions.push(getPos(e)); });
  
  canvas.addEventListener('touchstart', e => { 
    e.preventDefault();
    if (!gameOver) { 
      slicing = true; 
      slicePositions = [getPos(e)]; 
    }
  }, { passive: false });
  canvas.addEventListener('touchend', e => { 
    e.preventDefault();
    slicing = false; 
    slicePositions = []; 
  }, { passive: false });
  canvas.addEventListener('touchmove', e => { 
    e.preventDefault();
    if (slicing && !gameOver) slicePositions.push(getPos(e)); 
  }, { passive: false });

  function handleButtonAction(e) {
    const pos = getPos(e);
    const btn = checkButtonClick(pos.x, pos.y);
    if (btn === 'restart') {
      lifelines = 3; 
      score = 0; 
      foods = []; 
      gameOver = false;
    } else if (btn === 'quit') {
      window.location.href = 'https://google.com'; // Replace with your exit URL
    }
  }
  canvas.addEventListener('click', handleButtonAction);
  canvas.addEventListener('touchend', handleButtonAction);

  // Game loop
  function loop(ts) {
    // Background scrolling
    bgX1 -= bgScroll; bgX2 -= bgScroll;
    if (bgX1 <= -WIDTH) bgX1 = bgX2 + WIDTH;
    if (bgX2 <= -WIDTH) bgX2 = bgX1 + WIDTH;

    // Draw background
    ctx.drawImage(images.bg, bgX1, 0, WIDTH, HEIGHT);
    ctx.drawImage(images.bg, bgX2, 0, WIDTH, HEIGHT);

    if (!gameOver) {
      // Spawn food
      if (!lastSpawn || ts - lastSpawn > 1000) { 
        spawnFood(); 
        lastSpawn = ts; 
      }
      
      // Move and draw foods
      for (let i=foods.length-1; i>=0; i--) {
        foods[i].move();
        foods[i].draw();
        if (foods[i].y > HEIGHT+50) foods.splice(i,1);
      }
      
      // Slicing
      if (slicing && slicePositions.length > 1) {
        for (let i=foods.length-1; i>=0; i--) {
          if (!foods[i].sliced && slicePositions.some(pos => 
            foods[i].contains(pos.x, pos.y))) {
            foods[i].sliced = true;
            let kind = foods[i].kind;
            foods.splice(i,1);
            if (kind === 'veg' || kind === 'carrot') lifelines--;
            else score++;
          }
        }
        // Draw slice line
        ctx.strokeStyle = "red";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(slicePositions[0].x, slicePositions[0].y);
        for (let p of slicePositions) ctx.lineTo(p.x, p.y);
        ctx.stroke();
      }
      drawLifelines();
      drawScore();
      if (lifelines <= 0) gameOver = true;
    } else {
      ctx.font = "48px Arial";
      ctx.fillStyle = "red";
      ctx.fillText("Game Over!", WIDTH/2-120, HEIGHT/2-40);
      drawButtons();
    }
    requestAnimationFrame(loop);
  }
  loop();
}
  </script>
</body>
</html>
